Notre professeur est basé sur Eliza un agent conversationnel, ou «chatbot», mis en œuvre pour la première fois en 1966 par Joseph Weizenbaum et censé imiter un psychologue rogérien. Depuis lors, il y a eu diverses implémentations, plus ou moins similaires à l'original. Notre implémentation de Professeur est basée sur celle d'Eliza écrite à l'origine en Java  par Charles Chayden. Nous l'avons adapté de manière significative par soucis de simplification en utilisant certaines librairies de Java 8, cependant les dialogues, hormis les nôtres pour la partie dérivation, qont presque tous traduits du texte des structures de données deu fchier d'instruction de Charles Chayden.

Implementation

Professeur est un programme d'appariement de motifs. Il n'est pas beaucoup plus que cela. Pour cela on a utilisé la librairie Regex de Java, qui nous a facilité la tâche. Professeur commence par lire les fichiers de données puis attend une entrée utilisateur, la traite et formule sa réponse. Le traitement des entrées utilisateurs est contrôlé par plusieurs fichiers de donnnées, enregistrés sous un format csv. Ce traitement comprend les étapes suivantes :

1 -  Classe MotsCles : l'entrée utilisateur est décomposé en une liste de mots qui seront traités individuellement

2 - Classe Conjugaison : Une première substitution mappe les pronoms à la seconde personne en pronoms à la deuxième personne du pluriel pour marquer le vouvoiement. Il y a également une traduction d'expressions sms en français courant et quelques autres du langage vulgaire. Le fichiers "conjugaison-traduction.csv" est utilisé pour cela.

3 - Classe Reponse, Regex : Professeur utilise le fichier, "filtres-reponses.csv", qui est un fichier de données texte plat avec comme séparateur de données le pipe "|".
Exemple de ligne :
je|0|* je suis * @triste *|Je suis désolé d'apprendre que vous êtes (3).|Pensez-vous que venir ici vous aidera à ne pas être (3)?|Je suis sûr que ce n'est pas agréable d'être (3).|Pouvez-vous expliquer ce qui vous a fait (3)?

Le premier champ indique le mot-clé, le deuxième le poids, le troisième le filtre qui servira de regex et les suivants les réponses possibles qui seront choisies aléatoirement. Dans ces réponses, la numérotation entre parenthèse correspond aux groupes matchés par le regex du filtre.
Exemple : 
* je suis * @triste * --->  ([\p{L}\s\']*) suis ([\p{L}\s\']*) (triste) --> 3 groupes de match possibles --> le troisième remplacera "(3)" dans la réponse  "Pensez-vous que venir ici vous aidera à ne pas être (3)?".

Donc, la liste de mots-clés est créée à partir de ce fichier et de la liste de tous les mots de l'entrée utilisateur. Cette liste de mots clés est triée par poids décroissant et chaque mots clés traités jusqu'à produire une sortie.
(voir exemple précédent)
Pour un mot-clé donné, un filtre est recherchée dans le fichier "filtres-reponses.csv". La premiere correspondance est sélectionnée sinon passe au mot clé suivant. Pour un filtre correspondant, un template de réponse est choisi. Il peut y en avoir plusieurs, mais un seul est utilisé pour une entrée utilisateur donnée. Si une autre entrée sélectionne le même template de réponse, le filtre suivant est utilisé, jusqu'à épuisement. 

4 - Classe Conjugaison : Une seconde substitution a lieu, elle inverse le sujet et l'objet, par exemple le "je" de l'entrée utilisateur réutilisé dans le template de réponse devient "vous". Enfin, la réponse est affichée. Le fichiers "sujet-objet.csv" est utilisé pour cela.

De plus, il existe un fichier synonymes qui gère les filtres commençant par "@. Oon récupère les synonymes du termes suivant l'@ dans le fichier synonyme pour construire les regex qui seront utilisés les uns après les autres. 
exemple: entrée utilisateur 
"je suis triste...", 

mots clés "je". 
Première entrée trouvée dans le fichier"filtres-reponses.csv" 
"je|0|* je suis * @triste *|Je suis désolé d'apprendre que vous êtes (3).|...". 

"@triste" donne par le fichier "synonymes.csv", 
"triste|abattu|accablé|affecté..." 

et les regex créés
* je suis * (triste) *
* je suis * (abattu) *
* je suis * (accablé) *
* je suis * (affecté) *
etc...
chacun permettra de matcher l'entrée utilisateur. 
Classe Calcul : Un seul est différent, @dériver, il permet au Professeur d'utiliser la classe Calcul pour essayer de déterminer l'existence d'équations de fonctions dérivables dans l'entrée utilisateur et si oui, de tenter la dérivation den appelant les classes du des packages edu.projet.calcul et edu.projet.expressions. (voir ci-dessous)

Mots-clés spéciaux :
initiale: Professeur dit quand ça commence.
finale: Professeur dit quand ça termine.
quitter: si l'entrée est la suivante, Professeur quitte. 

Filtres spéciaux
Si un $ apparaît en premier dans un filtre, alors la réponse trouvée n'est pas en sortie mais enregistrée et Professeur passe au mot-clé suivant. Si aucun mot-clé
correspondent, et il y a des réponses mémorisées, l'une d'elles est choisie au hasard et utilisé, puis supprimée. S'il n'y a pas de réponses mémoriséess et aucun mot-clé trouvé, alors le mot-clé "xnone" est utilisé


Connecter Professeur à IRC

La version 0.3 est en en ligne de commande, mais nous avons pensé à la tester sur Internet. Pour cela, on relie le programme à un bot IRC qui lui se connecte à un serveur crée spécialement  pour cela. Le Professeur crée son propre canal et peut entrepr"endre de véritables conversations avec de vrais êtres humains.

Nous avons utiliser le framework PircBot écrit en Java qui permet de créer des bots IRC rapidement et facilement. Une classe est dédiée à cela. Ainsi Professeur pourra écouter les messages sur le canal que nous avons rejoint et vérifier s'ils sont adressés au bot. Si tel est le cas, nous transmettons le message à analyser à partir de la classe Professeur et écrivons la réponse sur le canal, précédée du pseudo de l'utilisateur qui a envoyé le message. Le bot se connectera au serveur, saisira le surnom «Professeur» et rejoindra le canal #ircprojet.


Pour construire toute la partie évaluation et dérivation d'expressions algébriques, le TP d'Ocaml nous a été utile. En effet, puisqu'une expression arithmétique peut être définie récursivement alors cela nous a incité à utiliser comme stratégie de mise en œuvre à utiliser le polymorphisme et la récursivité. 
Nous construisons la classe de base Expression est par conséquent qu iest la classe de base abstraite dont dérivent toutes les autres classes. Les objets de types dérivés de ces classes représenteront des expressions mathématiques données. 

Les classes dérivées d' Expression sont :
- Constante : constantes numériques detype float.
- Variable : ariables de types String
- Addition : expression + expression
- Multiplication : expression * expression
- Puissance  : expression ^ expression
- Moins  dérivée de Multiplication : signe moins, (Constante -1) x expression
- Soustraction dérivée d'Addition : expression +  Moins(expression)
- Division dérivée Multiplication, expression * expression ^(-1)  : 
Puisque nous devons effectuer des opérations sur un groupe d'objets de type similaire, nous avons décidé d'utiliser le pattern Visitor. Avec l'aide de ce modèle, nous avons déplacer la simplification et la dérivation d'expressions vers deux autres classes. Chaque élément de notre structure peuvent accepter un visiteur et doivent appliquer le visiteur à chaque classes dérivées. 
Pour implémenter les visitables, on a définit une interface Formules implémentée par la classe abstraite Expression dont dérivent toutes les autres.
Pour les visiteurs, on a implémenté les interfaces SimplificationVisitor, DerivationVisitor implémentées par les classes Simplification et Derivation.


Cette structure récursive, définit ainsi une arborescence d'expressions.qui nous a permis parcourir l'arbre d'une expression en profondeur en mode PostFixe, c'est à dire la notation polonaise inversée (connu grâce aux HP de mes années lycées en 80-83). Ceci a permis de transformer une expression en notation normale  et réciproquement. De cette façon, l'arbre d'expression complet peut être simplifié récursivement par la classe Simplification, même chose pour la dérivation. L'originalité est la réciproque utilisé par la classe Calcul dans le package professeur, qui après extraction d'une expression mathématiques de l'entr"e utilisateur, fabrique une expression donc un arbre qui sera traité par les classes ci-dessus nommés






